#!/usr/bin/env bash

usage(){
    cat <<-EOF
		USAGE: $0 FILE(s) CMD

		Run CMD every time one of FILE(s) is written to.

		FILE(s): Comma separated list of files
		CMD: Command to run when an event happens.

		- If CMD is long running the previous run of CMD is sent the TERM
		  signal and a new run is started when an event happens.
		- CMD is run whenever certain events happen to the watched files so not
		  exactly when the file is written to.  Other events are ignored like
		  opening the file which happens very frequently if we have an LSP
		  running
	EOF
}
case "$1" in -h|--help) usage ; exit 0 ;; esac
logprefix="\033[38;5;242m${0##*/}:main"
main(){
    local watch_cmd=$(get-watch-cmd)

    local -a files
    get_filenames "$1" ; shift
    if ((${#files[@]} == 0)) ; then
        echo "${0##*/}: ERROR: Zero files to watch" >&2
    fi

    local -a cmd=("$@")
    resolve_percent_by_ref cmd

    trap 'if kill -TERM ${run_pid} 2>/dev/null ; then wait ${run_pid} ; fi' EXIT

    export event_type event_file # Need to be available for the child process

    while true ; do
        if ! event=($(${watch_cmd} "${files[@]}")) ; then
            echo "${0}: Error in inotifywait command"
            exit 1
        fi
        event_file=${event[0]}
        event_type=${event[1]}

        # Disregard some events that are triggered too frequently [1]
        case ${event_type} in
            OPEN) printf "$logprefix: INFO: ignoring event: ${event[*]}\033[0m\n"
                  continue ;;
        esac

        # Kill previous invocation of CMD if there is one and wait for it to finish
        if kill ${run_pid} 2>/dev/null ; then wait ${run_pid} ; fi

        # Start next run and note it's PID
        bash -c 'run "$@"' "${0##*/}:run-handler" "${cmd[@]}" &
        run_pid=$!

        # Sleep to avoid reacting to groups of events.
        sleep 0.5
    done
}

run(){
    # Stack overflow answer: https://unix.stackexchange.com/a/146770/161630
    local caught_term=0
    _term() {
        # echo "$0: run process caught a signal"
        kill -TERM "$child_pid" 2>/dev/null
        caught_term=1
    }
    trap _term SIGTERM

    local c="\033[38;5;242m"
    printf "$c========================================================================\033[0m\n"
    printf "$c$0: Event: \033[36m%s\033[0m$c, File:\033[35m%s\033[0m\n" "${event_type}" "${event_file}"
    printf "$c$0: Starting command '\033[1m%s\033[0m'\n" "$*"

    bash -c "$*" &
    child_pid=$!

    wait ${child_pid}
    exit_code=$?

    if [[ ${caught_term} == 1 ]] ; then
        wait ${child_pid}
        printf "$c$0: Command '$*' ended by \033[1;33mTERM\033[0m\n"
    elif ! ((exit_code)) ; then
        printf "$c$0: Command '$*' ended with \033[1;32mSUCCESS\033[0m\n\n"
    else
        printf "$c$0: Command '$*' ended with \033[1;31mERROR: ${exit_code}\033[0m\n\n"
    fi
}
export -f run

watch_cmd_linux(){
    # -q suppresses startup output.  By default the inotifywait command prints
    # a single event and exits. See [2].
    inotifywait -q "${files[@]}"
}

watch_cmd_mac(){
    # Watch a file, by default, fswatch runs forever and ouputs a line for each
    # event that occurs.  See [2].
    fswatch -1 "$@"
}

#
# Change elements of array by replacing '%^' by the list of files and '%' by
# the first file.  This is inspired by $^ (whole dependency list) and '$<'
# (the first dependency) for Makefiles but with '%' instead of '%<' because
# '%<' would only work inside quotes (otherwise the '<'  would get interpreted
# as a redirection) while '%' and '%^' work outside of quotes.
#
resolve_percent_by_ref(){
    local -n _to_resolve=$1
    local i e
    for i in ${!_to_resolve[@]} ; do
        e=${_to_resolve[i]}
        e=${e//%^/${files[*]}}
        e=${e//%/${files[0]}}
        _to_resolve[i]=${e}
    done
}

get_filenames(){
    files=()
    if [[ "$1" == @* ]] ; then
        local dir
        case $1 in
            @:*) dir=$(git rev-parse --show-toplevel)/${1#@:} ;;
            @) dir=$PWD/${1#@}
        esac
        printf "$logprefix: INFO: Watching all tracked files in ${dir}\033[0m\n" >&2
        while read f ; do
            if [[ -L ${f} ]] ; then
                printf "$logprefix: INFO: ... except $f because it is a link\033[0m\n" >&2
                continue
            fi
            files+=("${f}")
        done < <(git ls-files ${dir})
        printf "$logprefix: INFO: watching '$1' gave ${#files[@]} files\033[0m\n" >&2
    else
        local IFS="${IFS},"
        files=($1)
        #
        # See [1] for why links deserve a warning
        #
        for f in "${files[@]}" ; do
            if [[ -L $f ]] ; then
                printf "\033[33mWARNING\033[0m: file '$f' is a link\n"
            fi
        done
    fi
}

get-watch-cmd(){
    local os="$(uname)"
    case "${os}" in
        Darwin) echo watch_cmd_mac ;;
        Linux)  echo watch_cmd_linux ;;
        *) echo "Unknown operating system : ${os}" ; exit 1 ;;
    esac
}

if ! (return 0 2>/dev/null) ; then
    main "$@"
fi

# [1]: Language servers may open files and any git operation will open most of
#      the files in a repo.
#
#      This has a drawback that seems to only occur when vim opens files through
#      a link.  When vim opens a normal file, when we save the file, the events
#      MOVE_SELF followed by OPEN occur.  However, when opening a link, only
#      the event OPEN happens
#
#      We warn if the one of the files is a link because as long as the real
#      file is opened with vim, it doesn't matter if this script receives the
#      link or the real file, we will see a MOVE_SELF event.
#
# [2]: Tested with VIM.  The inotifywait command takes a file name but it looks
#      up the inode number of that file and watches that inode.  The problem
#      with vim is that when we save, vim deletes the initial file and creates
#      a new one which means that it gets a new inode.  This is why the
#      commented out version below with 'inotifywait ${file} | while ... done'
#      doesn't work.  The following does work because with every event, we
#      relaunch inotifywait.
#
#      I'm not sure if this would be a problem with fswatch because I went with
#      the loop option to make inotifywait work.
#
