#!/usr/bin/env python3

import argparse
import re
import signal
import subprocess
import sys
import threading
import time
import watchdog.events
import watchdog.observers

STOP_PROGRAM = threading.Event()
STOP_RUN = threading.Event()

def get_args():
    p = argparse.ArgumentParser()
    p.add_argument("--filespec", help="space or comma separated list of files", required=True)
    p.add_argument("--recursive", action='store_true', help="Observe directories recursively")
    p.add_argument("--cmd", help="Command to run", required=True)
    args = p.parse_args()
    return args

def main():
    def stop_program(signum, trace):
        STOP_RUN.set()
        STOP_PROGRAM.set()
    signal.signal(signal.SIGINT, stop_program)
    signal.signal(signal.SIGTERM, stop_program)

    args = get_args()

    t = None
    while wait_for_event(args.filespec) and not STOP_PROGRAM.is_set():
        if t and t.is_alive():
            print(f"\033[38;5;242m{sys.argv[0]}: stopping previous run\033[0m")
            STOP_RUN.set()
            t.join()
        print(f"\033[38;5;242m{sys.argv[0]}: ======================================\033[0m")
        t = threading.Thread(target=run, args=(args.cmd,))
        t.start()

class EventHandler:
    def __init__(self, observer):
        self.observer = observer
    def dispatch(self, event: watchdog.events.FileSystemEvent):
        print(f"\033[38;5;242m{sys.argv[0]}: Event: {event.event_type} {event.src_path}\033[0m")
        self.observer.stop()


def wait_for_event(filespec):
    o = watchdog.observers.Observer()
    for f in re.split('[ ,\n]+', filespec):
        o.schedule(EventHandler(o), f, recursive=True,
                   event_filter=[watchdog.events.FileModifiedEvent])

    o.start()
    while o.is_alive():
        if STOP_PROGRAM.is_set():
            o.stop()
        time.sleep(0.5)
    o.join()

    return True


def run(cmd):
    p = subprocess.Popen(['bash', '-c', cmd])

    while not STOP_RUN.is_set() and p.poll() is None:
        time.sleep(0.5)

    if p.poll() is None:
        print(f"\033[38;5;242m{sys.argv[0]}: run: sending TERM to {p.pid}\033[0m")
        p.terminate()
    p.wait()

    print(f"\033[38;5;242m{sys.argv[0]}: run '\033[1;37m{cmd}\033[38;5;242m' ended with ", end='')
    if p.returncode == 0:
        print('\033[1;32mSUCCESS\033[0m')
    elif p.returncode == -15:
        print('\033[1;33mTERM\033[0m')
    else:
        print(f'\033[1;33mERROR {p.returncode}\033[0m')

    STOP_RUN.clear()


if __name__ == "__main__":
    main()
